use crate::types::*;
use crate::soundprim::*;

// Old note notation

pub fn kv545() -> impl Sound {
    let bass1 = vec![
        E(0), E(4), E(2), E(4), E(0), E(4), E(2), E(4),
        E(1), E(4), E(3), E(4), E(0), E(4), E(2), E(4),
        E(0), E(5), E(3), E(5), E(0), E(4), E(2), E(4),
        E(-1), E(4), E(1), E(4), E(0), E(4), E(2), E(4),

        Q(3), QR, QR, Ch(vec![Q(0), Q(-4)]),
        Ch(vec![Q(0), Q(-5)]), QR, QR, Ch(vec![Q(0), Q(-5)]),
        Ch(vec![Q(0), Q(-6)]), QR, QR, Ch(vec![Q(-1), Q(-6)]),
        Ch(vec![Q(0), Q(-7)]), QR, QR, Ch(vec![Q(-5), Q(-7)]),
    ];

    let mut treble1 = vec![
        H(7), Q(9), Q(11),
        Q(6).dot(), S(7), S(8), Q(7), QR,
        H(12), Q(11), Q(14),
        Q(11), T(10), T(11), T(10), T(11), S(9), S(10), Q(9), QR,
        /* ^ 4 Ts generated by trill */
    ];

    let treble_rep1 = vec![
        E(5), S(6), S(7), S(8), S(9), S(10), S(11), S(12),
        S(11), S(10), S(9), S(8), S(7), S(6), S(5),
    ];

    treble1.extend(treble_rep1.iter().cloned()
                   .chain(treble_rep1.iter().map(|x| x.higher(-1)))
                   .chain(treble_rep1.iter().map(|x| x.higher(-2)))
                   .chain(treble_rep1.iter().map(|x| x.higher(-3))));

    superpos(
        gen_notes(&bass1).map(|x| x * 0.2),
        gen_notes(&treble1).map(|x| x * 0.6))
        .map(|x| x * 0.3)
}

pub fn little_star() -> impl Sound {
    gen_notes(
        &[Q(0), Q(0), Q(4), Q(4), Q(5), Q(5), H(4),
        Q(3), Q(3), Q(2), Q(2), Q(1), Q(1), H(0)])
}

// Helpers

#[derive(Clone)]
enum N {
    W(i8),
    H(i8),
    Q(i8), QR,
    E(i8),
    S(i8),  // 16th
    T(i8),  // 32th
    Ch(Vec<N>),
    Dot(Box<N>),
}

impl N {
    fn is_rest(&self) -> bool {
        match self {
            QR => true,
            _ => false,
        }
    }

    fn is_chord(&self) -> bool {
        match self {
            Ch(_) => true,
            _ => false,
        }
    }

    fn freq_ix(&self) -> i8 {
        match self {
            W(x) => *x,
            H(x) => *x,
            Q(x) => *x,
            E(x) => *x,
            S(x) => *x,
            T(x) => *x,
            Dot(x) => x.freq_ix(),
            _ => panic!("Is a rest/chord"),
        }
    }

    fn higher(&self, n: i8) -> Self {
        match self {
            W(x) => W(x + n),
            H(x) => H(x + n),
            Q(x) => Q(x + n),
            E(x) => E(x + n),
            S(x) => S(x + n),
            T(x) => T(x + n),
            Dot(x) => x.higher(n).dot(),
            Ch(xs) => Ch(xs.iter().map(|x| x.higher(n)).collect()),
            _ => panic!("Is a rest"),
        }
    }

    fn freq(&self) -> f64 {
        // -7 to move C5 to C4.
        let mut ix = self.freq_ix() - 7;
        let mut pow2 = 0;
        while ix < 0 {
            ix += 7;
            pow2 -= 1;
        }
        while ix > 7 {
            ix -= 7;
            pow2 += 1;
        }
        assert!(ix >= 0 && ix <= 7);
        OCTAVE_4[ix as usize] * (2_f64.powi(pow2))
    }

    // Freq, duration
    fn dur(&self) -> f64 {
        match self {
            W(_) => 2.,
            H(_) => 1.,
            Q(_) => 0.5,
            QR => 0.5,
            E(_) => 0.25,
            S(_) => 0.125,
            T(_) => 0.125 * 0.5,
            Ch(xs) => xs.iter().map(|x| x.dur()).fold(0./0., f64::max),
            Dot(x) => 1.5 * x.dur(),
        }
    }

    fn dot(self) -> Self {
        Dot(Box::new(self))
    }
}

use self::N::*;

struct SoundBuilder {
    res: Option<Box<Sound>>,
    t: f64,
    bpm: usize,
}

impl SoundBuilder {
    fn build(&mut self, ns: &[N]) {
        for n in ns.iter() {
            if n.is_rest() {
                // Do nothing
            } else if let Ch(ns) = n {
                for n in ns {
                    self.build_n(n);
                }
            } else {
                self.build_n(n);
            }

            self.t += n.dur() * self.dur_factor();
        }
    }

    fn dur_factor(&self) -> f64 {
        120. / self.bpm as f64
    }

    fn build_n(&mut self, n: &N) {
        let dur = n.dur() * self.dur_factor();
        let freq = n.freq();
        let sleep = dur * 0.1;
        let ease = dur * 0.05;
        let note_dur = dur - sleep;

        let thiz = mult(sine(freq, note_dur), easing(ease, note_dur));
        if let Some(v) = self.res.take() {
            self.res = Some(Box::new(superpos(v, delay(self.t, thiz))));
        } else {
            self.res = Some(Box::new(thiz));
        }
    }
}

fn gen_notes(ns: &[N]) -> impl Sound {
    gen_notes_b(ns, 140)
}

fn gen_notes_b(ns: &[N], bpm: usize) -> impl Sound {
    let mut sb = SoundBuilder {
        res: None,
        t: 0.,
        bpm,
    };
    sb.build(ns);
    sb.res.unwrap()
}

