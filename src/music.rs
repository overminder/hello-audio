use std::f64::consts::PI;
use crate::geniter::GenIter;
use itertools::Itertools;
use itertools::EitherOrBoth::{Both, Left, Right};

pub fn kv545() -> impl Sound {
    let bass1 = vec![
        E(0), E(4), E(2), E(4), E(0), E(4), E(2), E(4),
        E(1), E(4), E(3), E(4), E(0), E(4), E(2), E(4),
        E(0), E(5), E(3), E(5), E(0), E(4), E(2), E(4),
        E(-1), E(4), E(1), E(4), E(0), E(4), E(2), E(4),

        Q(3), QR, QR, Ch(vec![Q(0), Q(-4)]),
        Ch(vec![Q(0), Q(-5)]), QR, QR, Ch(vec![Q(0), Q(-5)]),
        Ch(vec![Q(0), Q(-6)]), QR, QR, Ch(vec![Q(-1), Q(-6)]),
        Ch(vec![Q(0), Q(-7)]), QR, QR, Ch(vec![Q(-5), Q(-7)]),
    ];

    let mut treble1 = vec![
        H(7), Q(9), Q(11),
        Q(6).dot(), S(7), S(8), Q(7), QR,
        H(12), Q(11), Q(14),
        Q(11), T(10), T(11), T(10), T(11), S(9), S(10), Q(9), QR,
        /* ^ 4 Ts generated by trill */
    ];

    let treble_rep1 = vec![
        E(5), S(6), S(7), S(8), S(9), S(10), S(11), S(12),
        S(11), S(10), S(9), S(8), S(7), S(6), S(5),
    ];

    treble1.extend(treble_rep1.iter().cloned()
                   .chain(treble_rep1.iter().map(|x| x.higher(-1)))
                   .chain(treble_rep1.iter().map(|x| x.higher(-2)))
                   .chain(treble_rep1.iter().map(|x| x.higher(-3))));

    superpos(
        gen_notes(&bass1).map(|x| x * 0.2),
        gen_notes(&treble1).map(|x| x * 0.6))
        .map(|x| x * 0.3)
}

pub fn little_star() -> impl Sound {
    gen_notes(
        &[Q(0), Q(0), Q(4), Q(4), Q(5), Q(5), H(4),
        Q(3), Q(3), Q(2), Q(2), Q(1), Q(1), H(0)])
}

// Helpers

const SAMPLE_RATE: f64 = 44_100.0;
// Actually this is C5...
const OCTAVE_4: &'static [f64] = &[
    523.25,
    587.33,
    659.25,
    698.46,
    783.99,
    880.00,
    987.77,
    1046.50,
];

pub trait Sound = Iterator<Item=f32> + 'static;

pub fn sine(freq: f64, duration: f64) -> impl Sound {
    let ticks = (SAMPLE_RATE * duration) as usize;
    let step = freq / SAMPLE_RATE * 2.0 * PI;
    GenIter(move || {
        let mut x = 0_f64;
        for _ in 0..ticks {
            yield x.sin() as f32;
            x += step;
        }
    })
}

pub fn mult(x: impl Sound, y: impl Sound) -> impl Sound {
    x.zip(y).map(|(x, y)| x * y)
}

pub fn easing(e_dur: f64, duration: f64) -> impl Sound {
    let ticks = (SAMPLE_RATE * duration) as usize;
    let ease = (e_dur * SAMPLE_RATE) as usize;
    let ease_step = 1_f32 / (ease as f32);
    GenIter(move || {
        let mut out = 0.;
        for t in 0..ticks {
            if t < ease {
                out += ease_step;
            } else if t > ticks - ease {
                out -= ease_step;
            }
            yield out;
        }
    })
}

pub fn delay(duration: f64, s: impl Sound) -> impl Sound {
    let ticks = (SAMPLE_RATE * duration) as usize;
    GenIter(move || {
        for _ in 0..ticks {
            yield 0_f32;
        }
        for v in s {
            yield v;
        }
    })
}

pub fn superpos(x: impl Sound, y: impl Sound) -> impl Sound {
    x.zip_longest(y)
     .map(|xy| {
         match xy {
             Left(x) => x,
             Right(y) => y,
             Both(x, y) => x + y,
         }
     })
}

#[derive(Clone)]
enum N {
    W(i8),
    H(i8),
    Q(i8), QR,
    E(i8),
    S(i8),  // 16th
    T(i8),  // 32th
    Ch(Vec<N>),
    Dot(Box<N>),
}

impl N {
    fn is_rest(&self) -> bool {
        match self {
            QR => true,
            _ => false,
        }
    }

    fn is_chord(&self) -> bool {
        match self {
            Ch(_) => true,
            _ => false,
        }
    }

    fn freq_ix(&self) -> i8 {
        match self {
            W(x) => *x,
            H(x) => *x,
            Q(x) => *x,
            E(x) => *x,
            S(x) => *x,
            T(x) => *x,
            Dot(x) => x.freq_ix(),
            _ => panic!("Is a rest/chord"),
        }
    }

    fn higher(&self, n: i8) -> Self {
        match self {
            W(x) => W(x + n),
            H(x) => H(x + n),
            Q(x) => Q(x + n),
            E(x) => E(x + n),
            S(x) => S(x + n),
            T(x) => T(x + n),
            Dot(x) => x.higher(n).dot(),
            Ch(xs) => Ch(xs.iter().map(|x| x.higher(n)).collect()),
            _ => panic!("Is a rest"),
        }
    }

    fn freq(&self) -> f64 {
        // -7 to move C5 to C4.
        let mut ix = self.freq_ix() - 7;
        let mut pow2 = 0;
        while ix < 0 {
            ix += 7;
            pow2 -= 1;
        }
        while ix > 7 {
            ix -= 7;
            pow2 += 1;
        }
        assert!(ix >= 0 && ix <= 7);
        OCTAVE_4[ix as usize] * (2_f64.powi(pow2))
    }

    // Freq, duration
    fn dur(&self) -> f64 {
        match self {
            W(_) => 2.,
            H(_) => 1.,
            Q(_) => 0.5,
            QR => 0.5,
            E(_) => 0.25,
            S(_) => 0.125,
            T(_) => 0.125 * 0.5,
            Ch(xs) => xs.iter().map(|x| x.dur()).fold(0./0., f64::max),
            Dot(x) => 1.5 * x.dur(),
        }
    }

    fn dot(self) -> Self {
        Dot(Box::new(self))
    }
}

use self::N::*;

struct SoundBuilder {
    res: Option<Box<Sound>>,
    t: f64,
}

impl SoundBuilder {
    fn build(&mut self, ns: &[N]) {
        for n in ns.iter() {
            if n.is_rest() {
                // Do nothing
            } else if let Ch(ns) = n {
                for n in ns {
                    self.build_n(n);
                }
            } else {
                self.build_n(n);
            }

            self.t += n.dur();
        }
    }

    fn build_n(&mut self, n: &N) {
        let dur = n.dur();
        let freq = n.freq();
        let sleep = dur * 0.1;
        let ease = dur * 0.05;
        let note_dur = dur - sleep;

        let thiz = mult(sine(freq, note_dur), easing(ease, note_dur));
        if let Some(v) = self.res.take() {
            self.res = Some(Box::new(superpos(v, delay(self.t, thiz))));
        } else {
            self.res = Some(Box::new(thiz));
        }
    }
}

fn gen_notes(ns: &[N]) -> impl Sound {
    let mut sb = SoundBuilder {
        res: None,
        t: 0.,
    };
    sb.build(ns);
    sb.res.unwrap()
}

